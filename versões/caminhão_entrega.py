# -*- coding: utf-8 -*-
"""Caminh√£o.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19OsFj47cdM9fSEpMmjtAI3pPlEgIHG0X

*   Giulia Monteiro Garrido (RA: 24010281)
*   Thomaz Pinheiro Dacorso (RA: 24012310)
*   Vitor Riki Araujo Furuta (RA: 24008775)

Men√ß√£o honrosa: Fernando üòé

-----------------------------------

**Avalia√ß√£o:**

* Carregar arquivo corretamente (1pt)
* Gerar grafo inicial e plotar (1pt)
* Evidenciar pontes de interesse (que ser√£o usadas pelos caminhoneiros) (2pts)
* Responder o problema (2pts)
* Justificativas (4pts)
"""

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display
from functools import partial

import urllib.request
url = 'https://raw.githubusercontent.com/giu-garrido/graph-caminhao/refs/heads/main/teste.txt'
response = urllib.request.urlopen(url)
content = response.read().decode('utf-8')
print(content)

data = content.split()
print(data)

def leitura(data, index):

  N, M, S = int(data[index]), int(data[index+1]), int(data[index+2]) # Salva em N = n√∫mero de nodes, M = n√∫mero de arestas e S = n√∫mero de sedes
  index += 3 # Atualiza o index para depois dessas informa√ß√µes

  bridges = []
  for _ in range(M): # Percorre o n√∫mero de pontes
    A, B, P = int(data[index]), int(data[index+1]), int(data[index+2]) # Salva em A = in√≠cio, B = destino e P = weight (peso) da aresta
    index += 3 # Vai pra pr√≥xima aresta
    bridges.append((A, B, P))

  hq = []
  for _ in range(S): # Percorre o n√∫mero de sedes
    A, B = int(data[index]), int(data[index+1]) # Salva em A = in√≠cio, B = destino do caso teste
    index += 2 # Vai pra pr√≥xima sede
    hq.append((A, B))

  return N, M, S, bridges, hq, index

def criarGrafo(N, bridges):
  G = nx.Graph() # Cria o grafo

  for i in range(0, (N)): # Adiciona os nodes
    G.add_node(i+1)

  G.add_weighted_edges_from(bridges) # Adiciona as arestas com peso da lista pontes

  pos = nx.spring_layout(G, seed = 1) # Salva as posi√ß√µes do grafo no fromato spring, com uma seed para replica√ß√£o

  labels = {(A, B): P for A, B, P in bridges} # P√µe no formato com peso

  return G, labels, pos

def encontrarAGM(bridges, G):
  bridges.sort(key=lambda x: x[2], reverse=True) # Organiza a lista para maior peso -> menor peso

  T = nx.maximum_spanning_tree(G, weight='weight', algorithm='prim', ignore_nan=False) # Pega a √°rvore geradora m√°xima de G e salva em T
  aux = list(T.edges(data=True))
  l_p = dict()
  for a,b,p in aux: # Transforma para o formato necess√°rio
    w=p['weight']
    k=(a,b)
    l_p[k]=w

  return l_p, T

def caminho(T, hq):

  for a,b in hq:
    path = nx.shortest_path(T, a, b) # Menor caminho da AGM

    aux = np.inf # Come√ßa com infinito
    for i in range(len(path)-1):
      weights = T.get_edge_data(path[i], path[i+1])
      if weights.get('weight') < aux:
        aux = weights.get('weight') # Menor peso do caminho

    print(f'O maior peso que ele consegue carregar entre',{a}, 'e' ,{b}, '√©:',{aux})
  return path, aux

def printarGrafo(G, T, l_p,labels, pos, path):

  nx.draw(G, pos, with_labels=True, node_color="#f9b9ff", edge_color="gray", node_size=1000, font_size=15)
  nx.draw(T, pos, with_labels=True, node_color="#f9b9ff", edge_color="#75067F", node_size=1000, font_size=15)
  nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_color= "gray", font_size=10)
  nx.draw_networkx_edge_labels(G, pos, edge_labels=l_p, font_color= "#75067F", font_size=10)

  for i in range(len(path)-1): # "Grifa" o caminho do caminh√£o
      nx.draw_networkx_edges(T, pos, [(path[i], path[i+1])], width=10, edge_color= "#EFC3CA", alpha = 0.5)

  plt.show()

def on_button_clicked(b): # Fun√ß√£o para quando o bot√£o √© clicado
    global index, output

    with output:
      output.clear_output(wait=True)  # Limpa o que j√° estava desenhado

    if index >= len(data):
        print("Todos os casos j√° foram exibidos.")
        return

    N, M, S, bridges, hq, new_index = leitura(data, index) # Le pr√≥ximo caso
    index = new_index

    G, labels, pos = criarGrafo(N, bridges)

    opcoes = [] # Cria as op√ß√µes pra escolher o caminho
    for i in hq:
        opcao = str(i[0]) + ' - ' + str(i[1])
        opcoes.append(opcao)

    a = widgets.RadioButtons( # Cria os bot√µes dos caminhos
                options=opcoes,
                description='Caminhos:',
                disabled=False
            )

    handler_com_nome = partial(qualquer_funcao, grafo=G, bridges=bridges, pos = pos, labels = labels)

    a.observe(handler_com_nome, names='label')
    display(a)

index = 0
output = widgets.Output() # Pra mostrar as op√ß√µes de caminho
path_output = widgets.Output() # Pra mostrar o grafo

display(output)
display(path_output)

def qualquer_funcao(change, grafo, bridges, pos, labels): # Fun√ß√£o para quando escolher um caminho

  with path_output:
    path_output.clear_output(wait=True)

    origem, destino = map(int, change['new'].split(' - '))
    l_p, T = encontrarAGM(bridges, grafo)
    path,_ = caminho(T, [(origem, destino)])
    printarGrafo(grafo, T, l_p, labels, pos, path)

button = widgets.Button( # Cria o bot√£o de pr√≥ximo caso
    description='Pr√≥ximo Caso',
    disabled=False,
    button_style='info',
    tooltip='Carregar o pr√≥ximo caso',
    icon=''
)

button.on_click(on_button_clicked)
display(button)

on_button_clicked(None) # Carrega o primeiro caso automaticamente

